#+BEGIN_SRC c++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloWorld */

#ifndef _Included_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus

extern "C" {
#endif
/*
 * Class:     HelloWorld
 * Method:    print
 * Signature: ()V
 */

/* The most important part of the header file is the function prototype for Java_HelloWorld_print, which is the C function that implements the HelloWorld.print method: */
JNIEXPORT void JNICALL Java_HelloWorld_print
//
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif

#+END_SRC


as you a can see in the above, the function pototype convention for externally generatd C functions which 
map to java methods is ~Java_CLASS_NAME_METHOD-NAME~ 

great so for example, if our function was called sort, still within the class Helloworld
the function prototype would be :
#+BEGIN_SRC c++
#ifndef _Includedd_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus

extern "C" {
#endif

JNIEXPORT void JNICALL Java_HelloWorld_sort (JNIEnv *, jobject);

#ifdef __Cplusplus
}
#endif
#endif
#+END_SRC
 You may have noticed that the C implementation of the native method
 accepts two arguments even though the corresponding declaration of
 the native method accepts no arguments. The first argument for every
 native method implementation is a JNIEnv interface pointer. The
 second argument is a reference to the HelloWorld object itself (sort
 of like the “this” pointer in C++). We will discuss how to use the
 JNIEnv interface pointer and the jobject arguments later in this
 book, but this simple example ignores both arguments.

this suggest a formula for the number of argument a to a native function f
implementation of a function f₀

count(aₙₐₜ) = count(a) + 2
* implementation


